import { dirname, relative, sep, join } from "path";
import { createWriteStream } from "fs";

import walk from "./walk";
import { ZipFile } from "yazl";
import { mkdir } from "fs/promises";
import trimIndent from "./trimIndent";
import { PassThrough, Readable } from "stream";
import zip, { type ZipSource } from "./zip";

export type ZipEntryGenerator = AsyncGenerator<ZipSource, void, unknown>;

const USE_CUSTOM_ZIPPER = typeof process.env.USE_CUSTOM_ZIPPER !== "undefined";

type CommonJarArgs = {
    groupId: string;
    artifactId: string;
    version: string;
};

export type JarStreamArgs = CommonJarArgs & {
    asyncPathGeneratorFn(): ZipEntryGenerator;
};

export type JarArgs = CommonJarArgs & {
    targetPath: string;
    rootPath: string;
};

function getExtraFiles({ groupId, artifactId, version }: CommonJarArgs) {
    const manifestPath = "META-INF/MANIFEST.MF";
    const manifestData = Buffer.from(trimIndent`
            Manifest-Version: 1.0
            Archiver-Version: Plexus Archiver
            Created-By: Keycloakify
            Built-By: unknown
            Build-Jdk: 19.0.0
            `);

    const pomPropsPath = `META-INF/maven/${groupId}/${artifactId}/pom.properties`;
    const pomPropsData = Buffer.from(trimIndent`
            # Generated by keycloakify
            # ${new Date()}
            artifactId=${artifactId}
            groupId=${groupId}
            version=${version}
            `);

    return { manifest: { zipPath: manifestPath, data: manifestData }, pomProps: { zipPath: pomPropsPath, data: pomPropsData } };
}

export async function zipperStream({ groupId, artifactId, version, asyncPathGeneratorFn }: JarStreamArgs): Promise<NodeJS.ReadableStream> {
    /**
     * Append records for MANIFEST.mf and pom.properties
     */
    const pathToRecord = () =>
        new PassThrough({
            objectMode: true,
            final: function () {
                const { manifest, pomProps } = getExtraFiles({ groupId, artifactId, version });
                this.push(manifest);
                this.push(pomProps);
                this.push(null);
            }
        });

    return (
        Readable.from(asyncPathGeneratorFn())
            // transform every path into a ZipSource object
            .pipe(pathToRecord())
            // let the zip lib convert all ZipSource objects into a byte stream
            .pipe(zip())
    );
}

export async function yazlStream({ groupId, artifactId, version, asyncPathGeneratorFn }: JarStreamArgs): Promise<NodeJS.ReadableStream> {
    const zipFile = new ZipFile();

    for await (const entry of asyncPathGeneratorFn()) {
        if ("data" in entry) {
            zipFile.addBuffer(entry.data, entry.zipPath);
        } else if ("fsPath" in entry) {
            if (entry.fsPath.endsWith(sep)) {
                zipFile.addEmptyDirectory(entry.zipPath);
            } else {
                zipFile.addFile(entry.fsPath, entry.zipPath);
            }
        }
    }

    const { manifest, pomProps } = getExtraFiles({ groupId, artifactId, version });
    zipFile.addBuffer(manifest.data, manifest.zipPath, { compress: true });
    zipFile.addBuffer(pomProps.data, pomProps.zipPath, { compress: true });

    zipFile.end();

    return zipFile.outputStream;
}

/**
 * Create a jar archive, using the resources found at `rootPath` (a directory) and write the
 * archive to `targetPath` (a file). Use `groupId`, `artifactId` and `version` to define
 * the contents of the pom.properties file which is going to be added to the archive.
 * The root directory is expectedto have a conventional maven/gradle folder structure with a
 * single `pom.xml` file at the root and a `src/main/resources` directory containing all
 * application resources.
 */
export default async function jar({ groupId, artifactId, version, rootPath, targetPath }: JarArgs) {
    await mkdir(dirname(targetPath), { recursive: true });
    const resourcesPath = join(rootPath, "src", "main", "resources");

    const asyncPathGeneratorFn = async function* (): ZipEntryGenerator {
        for await (const fsPath of walk(resourcesPath)) {
            const zipPath = relative(resourcesPath, fsPath).split(sep).join("/");
            yield { fsPath, zipPath };
        }
        yield {
            fsPath: join(rootPath, "pom.xml"),
            zipPath: `META-INF/maven/${groupId}/${artifactId}/pom.xml`
        };
    };

    const zipStream = USE_CUSTOM_ZIPPER
        ? await zipperStream({ groupId, artifactId, version, asyncPathGeneratorFn })
        : await yazlStream({ groupId, artifactId, version, asyncPathGeneratorFn });

    await new Promise<void>(async (resolve, reject) => {
        zipStream
            .pipe(createWriteStream(targetPath, { encoding: "binary" }))
            .on("close", () => resolve())
            .on("error", e => reject(e));
    });
}
