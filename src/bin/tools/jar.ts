import { dirname, relative, sep, join } from "path";
import { createWriteStream } from "fs";

import walk from "./walk";
import { ZipFile } from "yazl";
import { mkdir } from "fs/promises";
import trimIndent from "./trimIndent";
import { Readable, Transform } from "stream";
import zip from "./zip";

export type ZipEntry = { zipPath: string } & ({ fsPath: string } | { buffer: Buffer });
export type ZipEntryGenerator = AsyncGenerator<ZipEntry, void, unknown>;

const zipper = process.env.KEYCLOAKIFY_ZIPPER ?? 'custom';

type CommonJarArgs = {
    groupId: string;
    artifactId: string;
    version: string;
};

export type JarStreamArgs = CommonJarArgs & {
    asyncPathGeneratorFn(): ZipEntryGenerator;
};

export type JarArgs = CommonJarArgs & {
    targetPath: string;
    rootPath: string;
};

function getExtraFiles({ groupId, artifactId, version }: CommonJarArgs) {

    const manifestPath = "META-INF/MANIFEST.MF";
    const manifestData = Buffer.from(trimIndent`
            Manifest-Version: 1.0
            Archiver-Version: Plexus Archiver
            Created-By: Keycloakify
            Built-By: unknown
            Build-Jdk: 19.0.0
            `);

    const pomPropsPath = `META-INF/maven/${groupId}/${artifactId}/pom.properties`;
    const pomPropsData = Buffer.from(trimIndent`
            # Generated by keycloakify
            # ${new Date()}
            artifactId=${artifactId}
            groupId=${groupId}
            version=${version}
            `);

    return { manifest: { path: manifestPath, data: manifestData }, pomProps: { path: pomPropsPath, data: pomPropsData } }
}

export async function zipperStream({ groupId, artifactId, version, asyncPathGeneratorFn }: JarStreamArgs) {
    /**
     * Convert every path entry to a ZipSource record, and when all records are
     * processed, append records for MANIFEST.mf and pom.properties
     */
    const pathToRecord = () =>
        new Transform({
            objectMode: true,
            transform: function ({ fsPath, zipPath }: { fsPath: string, zipPath: string }, _, cb) {
                this.push({ path: zipPath, fsPath });
                cb();
            },
            final: function () {
                const { manifest, pomProps } = getExtraFiles({ groupId, artifactId, version })
                this.push(manifest);
                this.push(pomProps);
                this.push(null);
            }
        });

    return Readable.from(asyncPathGeneratorFn())
        // transform every path into a ZipSource object
        .pipe(pathToRecord())
        // let the zip lib convert all ZipSource objects into a byte stream
        .pipe(zip())
}

export async function yazlStream({ groupId, artifactId, version, asyncPathGeneratorFn }: JarStreamArgs) {
    const { manifest, pomProps } = getExtraFiles({ groupId, artifactId, version })

    const zipFile = new ZipFile();

    for await (const entry of asyncPathGeneratorFn()) {
        if ("buffer" in entry) {
            zipFile.addBuffer(entry.buffer, entry.zipPath);
        } else if ("fsPath" in entry && !entry.fsPath.endsWith(sep)) {
            zipFile.addFile(entry.fsPath, entry.zipPath);
        }
    }

    zipFile.addBuffer(manifest.data, manifest.path);
    zipFile.addBuffer(pomProps.data, pomProps.path);

    zipFile.end();

    return zipFile.outputStream;
}

/**
 * Create a jar archive, using the resources found at `rootPath` (a directory) and write the
 * archive to `targetPath` (a file). Use `groupId`, `artifactId` and `version` to define
 * the contents of the pom.properties file which is going to be added to the archive.
 * The root directory is expectedto have a conventional maven/gradle folder structure with a
 * single `pom.xml` file at the root and a `src/main/resources` directory containing all
 * application resources.
 */
export default async function jar({ groupId, artifactId, version, rootPath, targetPath }: JarArgs) {
    await mkdir(dirname(targetPath), { recursive: true });
    const resourcesPath = join(rootPath, "src", "main", "resources");

    const asyncPathGeneratorFn = async function* (): ZipEntryGenerator {
        for await (const fsPath of walk(resourcesPath)) {
            const zipPath = relative(resourcesPath, fsPath).split(sep).join("/");
            yield { fsPath, zipPath };
        }
        yield {
            fsPath: join(rootPath, "pom.xml"),
            zipPath: `META-INF/maven/${groupId}/${artifactId}/pom.xml`
        };
    };

    const zipStream = zipper === 'yazl'
        ? await yazlStream({ groupId, artifactId, version, asyncPathGeneratorFn })
        : await zipperStream({ groupId, artifactId, version, asyncPathGeneratorFn })

    await new Promise<void>(async (resolve, reject) => {
        zipStream
            .pipe(createWriteStream(targetPath, { encoding: "binary" }))
            .on("close", () => resolve())
            .on("error", e => reject(e));
    });
}
