import { dirname, relative, sep, join } from "path";
import { createWriteStream } from "fs";

import walk from "./walk";
import { ZipFile } from "yazl";
import { mkdir } from "fs/promises";
import trimIndent from "./trimIndent";
import { Readable, Transform } from "stream";
import zip, { ZipSource } from "./zip";

export type ZipEntry = { zipPath: string } & ({ fsPath: string } | { buffer: Buffer });
export type ZipEntryGenerator = AsyncGenerator<ZipEntry, void, unknown>;

const zipper = process.env.KEYCLOAKIFY_ZIPPER ?? 'custom' as 'yazl' | 'custom';

type CommonJarArgs = {
    groupId: string;
    artifactId: string;
    version: string;
};

export type JarStreamArgs = CommonJarArgs & {
    asyncPathGeneratorFn(): ZipEntryGenerator;
};

export type JarArgs = CommonJarArgs & {
    targetPath: string;
    rootPath: string;
};

export async function jarStream({ groupId, artifactId, version, asyncPathGeneratorFn }: JarStreamArgs) {
    const manifestPath = "META-INF/MANIFEST.MF";
    const manifestData = Buffer.from(trimIndent`
            Manifest-Version: 1.0
            Archiver-Version: Plexus Archiver
            Created-By: Keycloakify
            Built-By: unknown
            Build-Jdk: 19.0.0
            `);

    const pomPropsPath = `META-INF/maven/${groupId}/${artifactId}/pom.properties`;
    const pomPropsData = Buffer.from(trimIndent`
            # Generated by keycloakify
            # ${new Date()}
            artifactId=${artifactId}
            groupId=${groupId}
            version=${version}
            `);

    const zipFile = new ZipFile();

    for await (const entry of asyncPathGeneratorFn()) {
        if ("buffer" in entry) {
            zipFile.addBuffer(entry.buffer, entry.zipPath);
        } else if ("fsPath" in entry && !entry.fsPath.endsWith(sep)) {
            zipFile.addFile(entry.fsPath, entry.zipPath);
        }
    }

    zipFile.addBuffer(manifestData, manifestPath);
    zipFile.addBuffer(pomPropsData, pomPropsPath);

    zipFile.end();

    return zipFile.outputStream;
}

/**
 * Create a jar archive, using the resources found at `rootPath` (a directory) and write the
 * archive to `targetPath` (a file). Use `groupId`, `artifactId` and `version` to define
 * the contents of the pom.properties file which is going to be added to the archive.
 * The root directory is expectedto have a conventional maven/gradle folder structure with a
 * single `pom.xml` file at the root and a `src/main/resources` directory containing all
 * application resources.
 */
export default async function jar({ groupId, artifactId, version, rootPath, targetPath }: JarArgs) {
    await mkdir(dirname(targetPath), { recursive: true });
    const resourcesPath = join(rootPath, "src", "main", "resources");

    const asyncPathGeneratorFn = async function* (): ZipEntryGenerator {
        for await (const fsPath of walk(resourcesPath)) {
            const zipPath = relative(resourcesPath, fsPath).split(sep).join("/");
            yield { fsPath, zipPath };
        }
        yield {
            fsPath: join(rootPath, "pom.xml"),
            zipPath: `META-INF/maven/${groupId}/${artifactId}/pom.xml`
        };
    };

    if (zipper === 'yazl') {
        const zipStream = await jarStream({ groupId, artifactId, version, asyncPathGeneratorFn });

        await new Promise<void>(async (resolve, reject) => {
            zipStream
                .pipe(createWriteStream(targetPath, { encoding: "binary" }))
                .on("close", () => resolve())
                .on("error", e => reject(e));
        });
    } else if (zipper === 'custom') {
        const manifest: ZipSource = {
            path: "META-INF/MANIFEST.MF",
            data: Buffer.from(trimIndent`
                    Manifest-Version: 1.0
                    Archiver-Version: Plexus Archiver
                    Created-By: Keycloakify
                    Built-By: unknown
                    Build-Jdk: 19.0.0`
            )
        };

        const pomProps: ZipSource = {
            path: `META-INF/maven/${groupId}/${artifactId}/pom.properties`,
            data: Buffer.from(trimIndent`
                    # Generated by keycloakify
                    # ${new Date()}
                    artifactId=${artifactId}
                    groupId=${groupId}
                    version=${version}`
            )
        };

        /**
         * Convert every path entry to a ZipSource record, and when all records are
         * processed, append records for MANIFEST.mf and pom.properties
         */
        const pathToRecord = () =>
            new Transform({
                objectMode: true,
                transform: function (fsPath, _, cb) {
                    const path = relative(resourcesPath, fsPath).split(sep).join("/");
                    console.log("Zipping", fsPath)
                    this.push({ path, fsPath });
                    cb();
                },
                final: function () {
                    this.push(manifest);
                    this.push(pomProps);
                    this.push(null);
                }
            });

        await mkdir(dirname(targetPath), { recursive: true });

        // Create an async pipeline, wait until everything is fully processed
        await new Promise<void>((resolve, reject) => {
            // walk all files in `resourcesPath` recursively
            Readable.from(walk(resourcesPath))
                // transform every path into a ZipSource object
                .pipe(pathToRecord())
                // let the zip lib convert all ZipSource objects into a byte stream
                .pipe(zip())
                // write that byte stream to targetPath
                .pipe(createWriteStream(targetPath, { encoding: "binary" }))
                .on("finish", () => resolve())
                .on("error", e => reject(e));
        });
    }
}
